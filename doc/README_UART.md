# README_UART.md

Этот файл описывает UART-подсистему проекта `primGPT` для `STM32F411` (BlackPill): прием/передача, таймаут кадра и связь ISR с задачами FreeRTOS.

---

# Шпаргалка: UART в STM32

## Что такое UART

UART (Universal Asynchronous Receiver-Transmitter) — последовательный интерфейс для передачи данных между устройствами по двум проводам.

```
  Устройство A                    Устройство B
  (например, ПК)                  (STM32F411 BlackPill)
  ┌───────────┐                   ┌───────────┐
  │           │  TX ──────► RX    │           │
  │   UART    │                   │  USART1   │
  │           │  RX ◄────── TX    │           │
  │           │                   │           │
  │           │  GND ────── GND   │           │
  └───────────┘                   └───────────┘
```

**Ключевые параметры:**
- **Baud rate** — скорость (бит/с). Оба устройства должны быть на одной скорости
- **Формат кадра** — сколько бит данных, чётность, стоп-биты (например 8N1 = 8 бит данных, No parity, 1 стоп-бит)
- **Нет тактового провода** — "асинхронный", синхронизация по стартовому биту

### Формат одного байта на проводе (8N1)

```
Линия TX/RX (idle = HIGH)
                                                  idle
─────┐  ┌──┐  ┌──┐  ┌──┐     ┌──┐  ┌──┐  ┌──┐  ┌─────
     │  │  │  │  │  │  │     │  │  │  │  │  │  │
     └──┘  └──┘  └──┘  └─...─┘  └──┘  └──┘  └──┘
     S  D0   D1   D2      D5   D6   D7   STOP

S     = Start bit (всегда 0, "провал" линии)
D0-D7 = 8 бит данных (LSB first)
STOP  = Stop bit (всегда 1)
```

На скорости 38400 бод один бит длится ~26 мкс, один байт (10 бит с start/stop) — ~260 мкс.

---

## Два UART в проекте — разные роли

```
┌──────────────────────────────────────────────────────────────┐
│                    STM32F411 BlackPill                        │
│                                                               │
│  USART1 (командный)              USART6 (отладочный)        │
│  ┌──────────────────┐           ┌───────────────────┐       │
│  │ PA9  = TX         │           │ PA11 = TX          │       │
│  │ PA10 = RX         │           │ PA12 = RX          │       │
│  │ 38400 бод, 8N1   │           │ 115200 бод, 8N1    │       │
│  │                   │           │                    │       │
│  │ Приём: по IRQ     │           │ Приём: нет (только │       │
│  │ (HAL_UART_        │           │   TX для логов)    │       │
│  │  Receive_IT)      │           │                    │       │
│  │                   │           │ Функции:           │       │
│  │ Протокол:         │           │ - log_printf()     │       │
│  │ CMD+DATA+CRC16    │           │ - printf_uart3()   │       │
│  └──────────────────┘           └───────────────────┘       │
│         ↕                              ↓                     │
│   Внешнее устройство           Терминал (PuTTY, minicom)    │
│   (отправляет команды)         (читает лог/диагностику)     │
└──────────────────────────────────────────────────────────────┘
```

### Почему две разные скорости

| | USART1 (командный) | USART6 (отладочный) |
|---|---|---|
| Скорость | 38400 бод | 115200 бод |
| Почему | Совместимость с внешним устройством, надёжность на длинных проводах | Скорость: лог-строки длинные, нужно передавать быстро |
| Направление | TX + RX (двухсторонний) | Только TX (логи наружу) |
| Прерывания | Да (RX по IRQ) | Нет (TX через HAL_UART_Transmit) |

---

## Аппаратная инициализация — что происходит при старте

При вызове `MX_USART1_UART_Init()` и `MX_USART6_UART_Init()` в `main.c`:

```
MX_USART1_UART_Init()  (main.c:363)
         │
         ▼
HAL_UART_Init(&huart1)
         │
         ▼
HAL_UART_MspInit()  (stm32f4xx_hal_msp.c:156)
┌──────────────────────────────────────────────────┐
│  1. Включить тактирование USART1:               │
│     __HAL_RCC_USART1_CLK_ENABLE()                │
│                                                   │
│  2. Настроить GPIO пины:                         │
│     PA9  → AF7 (USART1_TX), Push-Pull, VeryHigh │
│     PA10 → AF7 (USART1_RX), Push-Pull, VeryHigh │
│                                                   │
│  3. Настроить прерывание USART1:                 │
│     HAL_NVIC_SetPriority(USART1_IRQn, 5, 0)     │
│     HAL_NVIC_EnableIRQ(USART1_IRQn)              │
└──────────────────────────────────────────────────┘
         │
         ▼
HAL_UART_Receive_IT(&huart1, &uart1_rx_buf[0], 1)
         ← Запускает приём первого байта по прерыванию
```

**AF7** — Alternate Function 7: пин работает не как GPIO, а как USART1.

Для USART6 аналогично, но:
- Пины PA11 (TX), PA12 (RX) с AF8
- Прерывание НЕ включается (нет приёма по IRQ)

---

## Три способа передачи/приёма — что используется в проекте

### 1. Polling (блокирующий) — используется для TX

```c
// uart.c — передача одного байта (блокирует задачу до завершения)
HAL_UART_Transmit(&huart1, &ch, 1, HAL_MAX_DELAY);
```

Процессор ждёт, пока байт уйдёт. Просто, но блокирует задачу.

Используется в: `uart1_put_ch()`, `uart1_put_u16()`, `uart1_put_u32()`, `log_printf()`, `printf_uart3()`.

### 2. Interrupt (по прерыванию) — используется для RX

```c
// main.c:388 — запуск приёма 1 байта
HAL_UART_Receive_IT(&huart1, &uart1_rx_buf[0], 1);
```

HAL настраивает USART1 ждать байт. Когда байт придёт — вызовется прерывание → callback. Процессор свободен между байтами.

### 3. DMA (Direct Memory Access) — не используется (пока)

Аппаратура DMA сама перекладывает байты из USART→RAM без участия процессора. Для будущих оптимизаций при высокой скорости.

---

## Полный путь команды: от провода до ответа

```
Внешнее устройство отправляет кадр:
[CMD_ID | CMD_DATA | CRC16_LSB | CRC16_MSB]
Пример: [0x70, 0x01, 0xXX, 0xXX] — включить LED

Шаг 1. Приём байтов (ISR контекст, MSP стек)
═══════════════════════════════════════════════
Каждый байт:
  PA10 (RX) → USART1->DR → RXNE флаг → USART1_IRQHandler
  → HAL_UART_IRQHandler → HAL_UART_RxCpltCallback (uart.c:112)
  → ch = uart1_rx_buf[head]
  → xQueueSendFromISR(uartQueue, &ch)     ──→ в очередь
  → last_rx_time = xTaskGetTickCountFromISR()
  → HAL_UART_Receive_IT (rearm)
  → portYIELD_FROM_ISR

Шаг 2. Сборка кадра (Task контекст, PSP стек Uart1Task)
═══════════════════════════════════════════════
  Uart1Task (main.c:106):
  xQueueReceive(uartQueue, &receivedChar, 2 мс)
  command[index++] = receivedChar

Шаг 3. Определение конца кадра (таймаут)
═══════════════════════════════════════════════
  diff = xTaskGetTickCount() - last_rx_time
  if (index > 0 && diff > 20 мс):
    кадр собран → переход к обработке

  Почему 20 мс?
  - При 38400 бод один байт = ~0.26 мс
  - 4 байта кадра = ~1 мс
  - 20 мс = гарантированная пауза между кадрами

Шаг 4. Проверка CRC
═══════════════════════════════════════════════
  crc = process_crc(command, index, true)
  if (crc == 1):    ← CRC сошлась, кадр валидный
    обработка команды
  else:
    кадр отброшен (битые данные)

  CRC-16-MODBUS (polynomial 0xA001):
  - Считается по ВСЕМ байтам включая 2 байта CRC
  - Если кадр верный → результат = 0x0000
  - process_crc() возвращает 1 если CRC == 0

Шаг 5. Выполнение команды
═══════════════════════════════════════════════
  switch (command[0]):
    case 0x70:  ← управление LED
      command[1]==0 → LED OFF (PC13 = HIGH, active low)
      command[1]==1 → LED ON  (PC13 = LOW)

    case 0x02:  ← тест FRAM
      command[1]==0 → записать "KUREIN" в FRAM,
                      прочитать обратно

Шаг 6. Отправка ответа
═══════════════════════════════════════════════
  ok[2] = {ID_BU(1), 0x00}
  ok_ptr = calculate_crc_for_2_bytes(ok)
  → [0x01, 0x00, CRC_L, CRC_H]  (4 байта)
  for (i=0..3): uart1_put_ch(ok_ptr[i])
  → PA9 (TX) → провод → внешнее устройство

Шаг 7. Очистка
═══════════════════════════════════════════════
  Сбросить очередь (отбросить "хвосты"):
  while (uxQueueMessagesWaiting(uartQueue) > 0)
    xQueueReceive (discard)
  index = 0
  → готов к следующему кадру
```

---

## Кольцевой буфер приёма (uart.c)

В callback используется кольцевой буфер для защиты от потери байтов:

```
uart1_rx_buf[UART_BUF_SIZE]     UART_BUF_SIZE = 100 (DataFile.h)

  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
  │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ ...         │99│
  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
        ↑               ↑
       tail            head
       (чтение)        (запись ISR)

  head двигается вперёд при каждом принятом байте (в ISR)
  tail двигается вперёд при каждом прочитанном байте (в задаче)
  Если head догоняет tail → буфер переполнен
  → head и tail сбрасываются в 0
```

**Параллельно** с кольцевым буфером байт отправляется в `uartQueue` (FreeRTOS очередь на 40 элементов). Задача Uart1Task читает именно из очереди.

---

## Функции передачи в uart.c — краткая карта

| Функция | Что делает | UART | Блокирует? |
|---|---|---|---|
| `uart1_put_ch(ch)` | Отправить 1 байт | USART1 | Да (HAL_MAX_DELAY) |
| `uart1_put_u16(data)` | Отправить 2 байта (MSB first) | USART1 | Да |
| `uart1_put_u32(data)` | Отправить 4 байта (MSB first) | USART1 | Да |
| `uart6_put_ch(ch)` | Отправить 1 байт в лог | USART6 | Да |
| `log_printf(fmt, ...)` | printf в лог (128 B буфер) | USART6 | Да (100 мс timeout) |
| `printf_uart3(fmt, ...)` | printf в лог (128 B буфер) | USART6 | Да (100 мс timeout) |
| `uart_read(ch)` | Прочитать из кольцевого буфера | — | Нет (возвращает 0 если пусто) |

**Важно:** `log_printf` и `printf_uart3` используют буфер 128 байт на стеке. Это значит:
- Максимальная строка лога — 127 символов (+ '\0')
- Каждый вызов тратит ~128 B стека задачи + ~200 B на vsnprintf
- Нельзя вызывать из ISR (расходует MSP + слишком долго)

---

## CRC-16: как проверяется целостность кадра

```
Отправитель формирует кадр:
┌─────────┬──────────┬───────────┬───────────┐
│ CMD_ID  │ CMD_DATA │ CRC16_LSB │ CRC16_MSB │
│  1 байт │  1 байт  │  1 байт   │  1 байт   │
└─────────┴──────────┴───────────┴───────────┘

CRC считается по [CMD_ID, CMD_DATA]
и добавляется в конец (LSB first).

Получатель (STM32) считает CRC по ВСЕМ 4 байтам:
  crc16([CMD_ID, CMD_DATA, CRC_L, CRC_H])
  Если кадр не повреждён → результат = 0x0000
  process_crc() возвращает 1

Параметры CRC-16-MODBUS:
  - Init:       0xFFFF
  - Polynomial: 0xA001 (reflected 0x8005)
  - Порядок:    LSB first
```

### Ответ STM32

```
calculate_crc_for_2_bytes([ID_BU, 0x00])

Формирует 4 байта:
┌──────┬──────┬───────────┬───────────┐
│ 0x01 │ 0x00 │ CRC16_LSB │ CRC16_MSB │
│ ID_BU│Статус│           │           │
└──────┴──────┴───────────┴───────────┘

ВНИМАНИЕ: calculate_crc_for_2_bytes() использует static-буфер
→ функция НЕ реентрантна (нельзя вызывать из двух задач)
```

---

## Временная диаграмма приёма одного кадра

```
Время (мс)    0         1         2        22        25
              │         │         │         │         │
USART1 RX:   ═╤═╤═╤═╤══
              │B│y│t│e│ (4 байта кадра, ~1 мс)
              │0│1│2│3│
              └─┴─┴─┴─┘

ISR:          ↑ ↑ ↑ ↑   (4 прерывания, каждое ~5 мкс)
              │ │ │ │
              │ │ │ └→ xQueueSendFromISR(byte3)
              │ │ └──→ xQueueSendFromISR(byte2)
              │ └────→ xQueueSendFromISR(byte1)
              └──────→ xQueueSendFromISR(byte0)
                       last_rx_time = ~1 мс

Uart1Task:            ┌──────────────────────┐
              собирает│ command[0..3]        │ проверяет
              байты   │ ждёт ещё...          │ таймаут
              из      │ diff = tick - 1      │ каждые 3 мс
              очереди │ diff < 20 → ждём     │
                      └──────────────────────┘
                                    │
                        diff = 22 - 1 = 21 > 20 мс
                        ← КАДР ЗАВЕРШЁН!
                                    │
                                    ▼
                        process_crc() → switch → ответ
                        (ещё ~1 мс на обработку + TX)
```

**Итого:** от первого байта до ответа — ~23 мс (из них 20 мс — ожидание таймаута).

---

# Руководство по проекту

## 1) Какие UART используются

- `USART1` - командный интерфейс (RX/TX протокола).
- `USART6` - отладочный/лог-канал.

Основная логика протокола работает через `USART1`.

### Текущие настройки

Для `USART1`:
- `38400`, `8N1`, `UART_MODE_TX_RX`;
- прием по прерыванию `HAL_UART_Receive_IT(..., 1 byte)`;
- IRQ: `USART1_IRQn`.

Для `USART6`:
- `115200`, `8N1`, `UART_MODE_TX_RX`;
- используется в основном как TX для логов (`log_printf`, `printf_uart3`).

---

## 2) Как устроен прием в коде

Поток данных:

1. Стартует прием 1 байта: `HAL_UART_Receive_IT(&huart1, ..., 1)`.
2. После каждого байта вызывается `HAL_UART_RxCpltCallback()`.
3. ISR кладет байт в `uartQueue` через `xQueueSendFromISR`.
4. `Uart1Task` читает очередь (`xQueueReceive`) и собирает кадр.

Это RTOS-правильный шаблон: ISR короткая, разбор протокола в задаче.

---

## 3) Как определяется конец кадра

Конец кадра определяется по паузе между байтами:

- ISR обновляет `last_rx_time = xTaskGetTickCountFromISR();`
- задача считает `diff = xTaskGetTickCount() - last_rx_time`
- если `index > 0` и `diff > UART_TIMEOUT_MS`, кадр считается завершенным.

Текущее значение:

- `UART_TIMEOUT_MS = 20` (см. `Core/Inc/DataFile.h`).

---

## 4) Буфер и CRC

- Размер буфера кадра: `UART_BUF_SIZE = 100`.
- Проверка целостности: `CRC16` (`polynomial = 0xA001`).
- Входной кадр валиден, если `process_crc(..., true) == 1`.

Ответ формируется как 2 байта данных + 2 байта CRC:

- `[ID_BU, 0x00] + CRC16`.

---

## 5) Что важно для стабильности

- Всегда перезапускать прием в callback: `HAL_UART_Receive_IT(...)`.
- Использовать только ISR-safe API в прерывании (`...FromISR`).
- Не выполнять тяжелую логику/`HAL_Delay` в ISR.
- Для логов использовать ограниченный буфер и безопасную длину передачи.

---

## 6) Текущая диагностика по UART6

В `StartDefaultTask` раз в 5 секунд выводятся:

- `HeapB F:... Min:... Tot:...`
- `HeapU now:... peak:...`
- `StkB free D:... L:... U:...`
- `StkU % D:... L:... U:...`

Это позволяет контролировать heap/stack в runtime, а не только по ощущениям.
