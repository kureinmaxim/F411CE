# README_INTERRUPTS.md

Документ описывает систему прерываний в `primGPT` для `STM32F411` и ее связь с FreeRTOS.

---

# Шпаргалка: прерывания в STM32 + FreeRTOS

## Что такое прерывание и зачем оно нужно

Прерывание (IRQ) — аппаратный сигнал, который **останавливает** текущий код (задачу) и переключает процессор на обработчик (ISR). После ISR — код продолжает с того же места.

```
Задача работает ──────►┐
                       │ IRQ! (например, пришёл байт UART)
                       ▼
              ┌─ ISR (обработчик) ─────────────┐
              │  Быстро обработать событие:     │
              │  - сохранить байт               │
              │  - отправить в очередь           │
              │  - перезапустить приём            │
              └─────────────────────────────────┘
                       │
Задача продолжает ◄────┘
```

**Главное правило:** ISR должен быть **максимально коротким** — записал данные, вышел. Вся тяжёлая обработка — в задачах FreeRTOS.

---

## Как устроен NVIC (контроллер прерываний)

NVIC (Nested Vectored Interrupt Controller) — аппаратный блок Cortex-M4, управляющий прерываниями.

```
┌──────────────────────────────────────────────────────────┐
│                        NVIC                               │
│                                                           │
│  Что делает:                                             │
│  1. Включает/выключает каждое прерывание                 │
│  2. Назначает приоритет (0-15)                           │
│  3. Определяет, кто вытеснит текущий ISR (вложенность)   │
│  4. Хранит таблицу векторов — адресов обработчиков       │
│                                                           │
│  Приоритеты в Cortex-M (4 бита = 16 уровней):           │
│  ┌──────────────────────────────────────────────────┐    │
│  │  0  = САМЫЙ ВЫСОКИЙ (вытеснит всех)              │    │
│  │  1  │                                            │    │
│  │  2  │  ← НЕ вызывать FreeRTOS API отсюда!       │    │
│  │  3  │    (приоритет выше configMAX_SYSCALL)      │    │
│  │  4  │                                            │    │
│  │ ─── ╋ ─── configMAX_SYSCALL_INTERRUPT_PRIORITY ──│    │
│  │  5  │  ← USART1 (наш проект)                    │    │
│  │  6  │  ← можно вызывать ...FromISR()            │    │
│  │  ...│                                            │    │
│  │ 14  │                                            │    │
│  │ 15  = САМЫЙ НИЗКИЙ                               │    │
│  │      ← PendSV, SysTick (ядро FreeRTOS)          │    │
│  └──────────────────────────────────────────────────┘    │
│                                                           │
│  ВАЖНО: меньше число = ВЫШЕ приоритет (наоборот!)        │
└──────────────────────────────────────────────────────────┘
```

**Ключевая граница** — `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY = 5` (задаётся в `FreeRTOSConfig.h`, строка 145).

- Прерывания с приоритетом **5, 6, 7, ... 15** — МОГУТ вызывать `...FromISR()` API FreeRTOS
- Прерывания с приоритетом **0, 1, 2, 3, 4** — НЕ МОГУТ (иначе — HardFault или порча данных)

---

## Прерывания в этом проекте — полная карта

```
Таблица векторов (startup_stm32f411ceux.s)
═══════════════════════════════════════════════════════════

Адрес      Вектор                    Приоритет    Файл обработчика
──────────────────────────────────────────────────────────
0x00       MSP (начальный стек)       —           (не ISR)
0x04       Reset_Handler              -3 (фикс)   startup_stm32f411ceux.s
0x08       NMI_Handler                -2 (фикс)   stm32f4xx_it.c
0x0C       HardFault_Handler          -1 (фикс)   stm32f4xx_it.c
0x10       MemManage_Handler          настр.       stm32f4xx_it.c
0x14       BusFault_Handler           настр.       stm32f4xx_it.c
0x18       UsageFault_Handler         настр.       stm32f4xx_it.c
...
0x2C       SVC_Handler                настр.       FreeRTOS port.c
0x38       PendSV_Handler             15           FreeRTOS port.c
0x3C       SysTick_Handler            15           stm32f4xx_hal.c
...
           TIM1_UP_TIM10_IRQHandler   по умолч.    stm32f4xx_it.c
           USART1_IRQHandler          5            stm32f4xx_it.c
──────────────────────────────────────────────────────────
```

### Кто где настраивается

| Прерывание | Приоритет | Где задаётся | Что делает обработчик |
|---|---|---|---|
| **USART1** | 5, sub 0 | `stm32f4xx_hal_msp.c:180` | Приём байта → очередь FreeRTOS |
| **TIM1 Update** | по умолч. | CubeMX (NVIC) | `HAL_IncTick()` — системный таймер HAL |
| **PendSV** | 15 (самый низкий) | `stm32f4xx_hal_msp.c:75` | Переключение контекста задач FreeRTOS |
| **SVC** | — | FreeRTOS | Запуск планировщика (`osKernelStart`) |
| **SysTick** | — | HAL/FreeRTOS | Тик 1 мс для `vTaskDelay()` |

---

## Как работает прерывание USART1 — подробная схема

Это главное прерывание проекта. Обеспечивает приём команд по UART1 (38400 бод).

```
   Внешнее устройство отправляет байт по UART1 (PA10 = RX)
                        │
                        ▼
┌─ Аппаратура USART1 ──────────────────────────────────────┐
│  Байт принят в аппаратный регистр USART1->DR             │
│  Флаг RXNE = 1                                           │
│  NVIC видит: USART1_IRQn включён, приоритет 5            │
│  → Вызов USART1_IRQHandler()                             │
└──────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─ USART1_IRQHandler() ─── stm32f4xx_it.c:180 ────────────┐
│  HAL_UART_IRQHandler(&huart1);   ← HAL читает DR,       │
│                                     сбрасывает флаги,    │
│                                     вызывает callback    │
└──────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─ HAL_UART_RxCpltCallback() ─── uart.c:112 ───────────────┐
│                                                           │
│  if (huart->Instance == USART1) {                        │
│                                                           │
│    // 1. Извлечь байт из кольцевого буфера               │
│    uint8_t ch = uart1_rx_buf[uart1_rx_head];             │
│                                                           │
│    // 2. Продвинуть head (или сброс при overflow)        │
│    uart1_rx_head = (uart1_rx_head + 1) % UART_BUF_SIZE;  │
│                                                           │
│    // 3. Отправить байт в очередь FreeRTOS               │
│    BaseType_t woken = pdFALSE;                           │
│    xQueueSendFromISR(uartQueue, &ch, &woken);            │
│    //  ↑ ISR-безопасная версия! Обычный xQueueSend       │
│    //    вызывать НЕЛЬЗЯ — заблокирует ISR               │
│                                                           │
│    // 4. Обновить таймштамп последнего байта              │
│    last_rx_time = xTaskGetTickCountFromISR();             │
│                                                           │
│    // 5. Перезапустить приём следующего байта             │
│    HAL_UART_Receive_IT(&huart1, &uart1_rx_buf[...], 1);  │
│    //  ↑ Без этого UART "замолчит" после первого байта!  │
│                                                           │
│    // 6. Переключить задачу если нужно                   │
│    portYIELD_FROM_ISR(woken);                            │
│    //  ↑ Если Uart1Task ждал очередь и она была пуста,   │
│    //    теперь он готов к работе — переключиться сразу   │
│  }                                                       │
└──────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─ Uart1Task ─── main.c:106 ──────────────────────────────┐
│  xQueueReceive(uartQueue, &receivedChar, ...)            │
│  // Собирает байты в command[], ждёт таймаут 20 мс,     │
│  // затем проверяет CRC и выполняет команду             │
└──────────────────────────────────────────────────────────┘
```

---

## Как работает прерывание TIM1 — таймер HAL

```
┌─ Аппаратура TIM1 ───────────────────────────────────────┐
│  TIM1 считает тики, каждую 1 мс → Update Event          │
│  NVIC → TIM1_UP_TIM10_IRQHandler()                      │
└─────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─ TIM1_UP_TIM10_IRQHandler() ─── stm32f4xx_it.c:166 ────┐
│  HAL_TIM_IRQHandler(&htim1);                             │
└─────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─ HAL_TIM_PeriodElapsedCallback() ─── main.c:526 ────────┐
│  if (htim->Instance == TIM1) {                           │
│      HAL_IncTick();   ← увеличивает uwTick на 1         │
│  }                    ← используется HAL_GetTick(),      │
│                         HAL_Delay() и т.д.               │
└─────────────────────────────────────────────────────────┘
```

**Почему TIM1, а не SysTick для HAL?** Потому что SysTick отдан FreeRTOS (для `vTaskDelay`, переключения задач). HAL нужен свой отдельный источник тиков — это TIM1.

---

## Память и стеки в контексте прерываний

### Какой стек используют ISR

```
┌───────────────────────────────────────────────────────────┐
│                                                           │
│  Cortex-M4 имеет ДВА указателя стека:                    │
│                                                           │
│  MSP (Main Stack Pointer)                                │
│  ├── Используется при старте (до FreeRTOS)               │
│  ├── Используется ВСЕМИ прерываниями (ISR)               │
│  └── Размер: _Min_Stack_Size = 1024 B (в линкер-скрипте)│
│      Живёт в верху RAM, растёт от 0x20020000 вниз        │
│                                                           │
│  PSP (Process Stack Pointer)                              │
│  ├── Используется задачами FreeRTOS                      │
│  ├── У каждой задачи свой PSP (свой стек)                │
│  └── Переключается при смене контекста (PendSV)          │
│                                                           │
│  Переключение MSP ↔ PSP — аппаратное!                   │
│  При входе в ISR процессор автоматически:                │
│  1. Сохраняет 8 регистров в текущий PSP (стек задачи)   │
│  2. Переключается на MSP                                 │
│  3. Выполняет ISR на MSP                                 │
│  4. При выходе — восстанавливает PSP и продолжает задачу │
│                                                           │
└───────────────────────────────────────────────────────────┘
```

### Сколько стека тратит ISR

При каждом прерывании процессор автоматически кладёт на MSP:

| Что | Размер |
|---|---|
| Аппаратный stacking (r0-r3, r12, LR, PC, xPSR) | 32 байта |
| + выравнивание до 8 байт | 0-4 байта |
| Локальные переменные ISR (callback) | зависит от кода |
| Вложенное прерывание (если произойдёт) | ещё 32+ байт |

**Для USART1 callback** (uart.c): локальных переменных мало (ch, next_head, woken) — ~20 байт. Итого один ISR: ~60 байт MSP.

**Для TIM1 callback** (main.c): только `HAL_IncTick()` — ~40 байт MSP.

**При вложенности** (TIM1 прерывает USART1 ISR) — оба лягут на MSP последовательно: ~100 байт. MSP = 1024 B — хватает с запасом.

### Когда MSP может переполниться

```
MSP = 1024 B

Нормальная нагрузка:
  ISR USART1 (~60 B) + вложенный TIM1 (~40 B) = ~100 B  OK

Опасная ситуация:
  Если бы в ISR был printf() (~300 B) + вложенный ISR (~40 B)
  + ещё один вложенный (~40 B) = ~380 B  Внимание!

Критическая ситуация:
  printf внутри ISR + sprintf внутри printf + вложенные ISR
  может съесть 500-800 B из 1024 B → CRASH
```

**Вывод:** никогда не вызывать printf/log_printf из ISR. Только `xQueueSendFromISR` + данные обрабатывать в задаче.

---

## Путь данных: от провода до обработки команды

Полная схема от физического сигнала до действия:

```
                  UART TX устройство
                        │
                 ─── провод (TX→RX) ───
                        │
                      PA10 (USART1_RX)
                        │
┌───── АППАРАТУРА ──────┤
│  USART1 принимает     │
│  8N1 @ 38400 бод      │
│  → RXNE флаг          │
│  → NVIC → IRQ         │
└───────────────────────┘
         │
         ▼ ISR контекст (MSP стек, ~60 B)
┌───── ISR ─────────────┐
│  USART1_IRQHandler     │──→ HAL_UART_IRQHandler
│                        │──→ HAL_UART_RxCpltCallback
│  uart.c:112            │
│  ┌────────────────────┐│
│  │ ch = буфер[head]   ││
│  │ head++             ││
│  │ xQueueSendFromISR  ││──→ uartQueue (40 элементов)
│  │ last_rx_time = tick││
│  │ Receive_IT(rearm)  ││
│  │ portYIELD_FROM_ISR ││
│  └────────────────────┘│
└────────────────────────┘
         │
         ▼ Task контекст (PSP стек Uart1Task, 2048 B)
┌───── Uart1Task ────────┐
│  main.c:106             │
│  while(1) {             │
│    xQueueReceive        │←── uartQueue
│    command[index++]=ch  │
│                         │
│    if (таймаут 20 мс) { │    DataFile.h: UART_TIMEOUT_MS=20
│      process_crc()      │    Проверка CRC-16
│      switch(command[0]) │
│        case 0x70:       │──→ LED on/off (GPIO PC13)
│        case 0x02:       │──→ FRAM write/read test
│      send response      │──→ uart1_put_ch (TX по USART1)
│      очистить очередь   │
│    }                    │
│    vTaskDelay(3 мс)     │
│  }                      │
└─────────────────────────┘
```

---

## API FreeRTOS: обычные vs ISR-безопасные

| Из задачи (обычный) | Из ISR (безопасный) | Разница |
|---|---|---|
| `xQueueSend()` | `xQueueSendFromISR()` | ISR-версия не блокируется, принимает `pxHigherPriorityTaskWoken` |
| `xQueueReceive()` | `xQueueReceiveFromISR()` | |
| `xSemaphoreGive()` | `xSemaphoreGiveFromISR()` | |
| `xTaskGetTickCount()` | `xTaskGetTickCountFromISR()` | ISR-версия не берёт блокировку |
| `taskENTER_CRITICAL()` | `taskENTER_CRITICAL_FROM_ISR()` | |
| `vTaskDelay()` | **НЕЛЬЗЯ из ISR!** | Задержка = блокировка, ISR не может ждать |
| `printf() / log_printf()` | **НЕЛЬЗЯ из ISR!** | Слишком долго + расходует MSP |

**Что будет если вызвать обычную версию из ISR:** `configASSERT` сработает → бесконечный цикл с выключенными прерываниями → зависание.

---

## portYIELD_FROM_ISR — зачем нужен

```
Без portYIELD_FROM_ISR:
──────────────────────────────────────────────────
  LedTask работает ──► IRQ ──► ISR кладёт байт в очередь
                                │
                                ▼
                       Возврат в LedTask  ← продолжает!
                       ...через 1мс (тик)...
                       Планировщик: "о, Uart1Task готов!"
                       Переключение на Uart1Task
                       ← задержка до 1 мс!

С portYIELD_FROM_ISR:
──────────────────────────────────────────────────
  LedTask работает ──► IRQ ──► ISR кладёт байт в очередь
                                │
                                ▼
                       portYIELD_FROM_ISR(pdTRUE)
                       Переключение на Uart1Task  ← СРАЗУ!
                       ← задержка ~0 мс
```

В нашем проекте это важно для быстрого отклика на UART-команды.

---

## Обработка ошибочных прерываний (Fault Handlers)

Все fault-обработчики в `stm32f4xx_it.c` уходят в `while(1)` — плата зависает.

| Fault | Когда возникает | Типичная причина в RTOS-проекте |
|---|---|---|
| **HardFault** | Ошибка доступа к памяти, неверный адрес | Stack overflow задачи, обращение по NULL |
| **MemManage** | Нарушение защиты памяти (MPU) | Обычно не встречается (MPU выключен) |
| **BusFault** | Ошибка на шине (обращение к несущ. адресу) | Неинициализированный указатель |
| **UsageFault** | Невалидная инструкция, деление на 0 | Порча стека → невалидный PC |

**Как отлаживать HardFault:**
1. Подключить отладчик (ST-Link)
2. В момент зависания посмотреть регистры: `SCB->CFSR`, `SCB->HFSR`, `SCB->BFAR`
3. Стек вызовов покажет откуда пришли
4. Чаще всего — увеличить `stack_size` задачи

---

# Руководство по проекту

## 1) Задействованные прерывания

### Системные (Cortex-M4)

- `SVC_Handler`
- `PendSV_Handler`
- `SysTick_Handler`
- `HardFault/MemManage/BusFault/UsageFault`

### Периферийные

- `USART1_IRQHandler`
  - вызывает `HAL_UART_IRQHandler(&huart1)`;
  - далее `HAL_UART_RxCpltCallback()` в `uart.c`.

- `TIM1_UP_TIM10_IRQHandler`
  - вызывает `HAL_TIM_IRQHandler(&htim1)`;
  - `HAL_TIM_PeriodElapsedCallback()` делает `HAL_IncTick()`.

---

## 2) Поток приема UART1

```text
USART1_RX byte
  -> USART1 IRQ
  -> USART1_IRQHandler()
  -> HAL_UART_IRQHandler(&huart1)
  -> HAL_UART_RxCpltCallback()
  -> xQueueSendFromISR(uartQueue, byte, &xHigherPriorityTaskWoken)
  -> HAL_UART_Receive_IT(..., 1)   // rearm RX
  -> portYIELD_FROM_ISR(...)       // при необходимости
  -> Uart1Task в task context
```

---

## 3) Приоритеты и FreeRTOS

Ключевые параметры в `FreeRTOSConfig.h`:

- `configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY = 5`
- `configMAX_SYSCALL_INTERRUPT_PRIORITY` вычисляется из него.

Правило:

- ISR, где используются `...FromISR`, должны иметь допустимый приоритет относительно `configMAX_SYSCALL_INTERRUPT_PRIORITY`.

---

## 4) Что можно/нельзя в ISR

Можно:

- короткая фиксация события;
- отправка в очередь `xQueueSendFromISR`;
- обновление таймштампа;
- rearm приема `HAL_UART_Receive_IT`.

Нельзя:

- долгие циклы, парсинг протокола целиком;
- блокирующие вызовы (`HAL_Delay`);
- тяжелые `printf`;
- обычные (не ISR) API FreeRTOS.

---

## 5) Практические рекомендации

- Если прием "останавливается", первым делом проверять rearm `HAL_UART_Receive_IT`.
- Если callback не вызывается - проверять `USART1_IRQHandler`, NVIC enable и приоритет.
- Для роста скорости рассмотреть `DMA RX + ring buffer`.
